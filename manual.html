<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
	<script src="tools/jquery-3.1.1.min.js"></script>
	<script src="clarino.min.js"></script>

	<script>
	(function($, $C){
		//console.log($C);
		var $H = $C.simple;
		var showTests = document.location.hash=='#test';
		// console.log('showTests: %s', showTests);

		var px = $C.css.unit.px,
			pc = $C.css.unit.pc,
			css = $C.css.keywords;

		var Settings = {
			title: $C.format('Clarino v.{0} - руководство пользователя', Clarino.version()),
			link:{
				color:{
					lo:'#00a',
					hi:'#06a'
				}
			}
		};

		$C.css.writeStylesheet({
			'h1,h2,h3,h4':{
				marginBottom:px(0)
			},
			'.manual':{
				fontFamily: 'Verdana, Arial, Sans-Serif',
				fontSize: px(14),
				' a':{
					':link':{color:Settings.link.color.lo},
					':visited':{color:Settings.link.color.lo},
					':hover':{color:Settings.link.color.hi}
				},
				' .button':{
					cursor: css.pointer
				},
				' .navbar':{
					backgroundColor: '#eee',
					padding: px(3, 50),
					margin: px(0, 0, 20, 0),
					' a':{
						':link':{textDecoration:css.none},
						':visited':{textDecoration:css.none},
						':hover':{textDecoration:css.underline}
					}
				},
				' .code':{
					backgroundColor: '#eaeaea',
					fontFamily: 'Courier New, Monospace'
				},
				' span.code':{
					whiteSpace: css.nowrap
				},
				' .attention':{
					color: '#f00'
				},
				' div.attention':{
					margin: px(5),
					color: '#000',
					padding: px(0, 10),
					borderLeft: '8px solid #f00'
				},
				' .comment':{
					fontStyle: css.italic
				},
				' .pnlErrorsDetected':{
					display: css.none,
					backgroundColor: '#ffc',
					padding: px(10),
					fontWeight: css.bold,
					border: px(1)+' solid #f00'
				},
				' .success':{color:'#080'},
				' .error':{color:'#e00'},
				' .skinSelector':{
					position:css.fixed,
					top:px(10),
					left:'calc(100vw - 250px)'
				}
			}
		});

		var Skins = {
			default:{
				name:'светлое',
				styles:{}
			},
			dark:(function(){
				var color = {
					back:'#012',
					text:'#eef',
					nav:{
						back:'#88a',
						text:'#002'
					},
					link:{
						lo:'#efe',
						hi:'#bfb'
					},
					code:{
						back:'#283035',
						text:'#eef'
					}
				};
				return {
					name:'темное',
					styles:{
						'body':{
							backgroundColor:color.back,
							color:color.text,
							' .manual':{
								' a':{
									':link':{color:color.link.lo},
									':visited':{color:color.link.lo},
									':hover':{color:color.link.hi}
								},
								' .navbar':{
									backgroundColor:color.nav.back,
									color:color.nav.text,
									' a':{
										':link':{color:color.nav.text},
										':visited':{color:color.nav.text},
										':hover':{color:color.nav.text}
									}
								},
								' .code':{
									backgroundColor:color.code.back,
									color:color.code.text
								},
								' div.attention':{
									color:'#ffc'
								},
								' div.error':{
									backgroundColor:'#ff0',
									border:$C.css.template.border(2, '#f00'),
									padding:px(5)
								}
							}
						}
					}
				};
			})()
		};

		var uid = (function(){
			var counter = 1;
			return function(){
				return counter++;
			};
		})();

		function listOfMethods(obj){with($H){
			var list = [];
			for(var k in obj){
				list.push(k);
			}
			list.sort();
			return markup(
				apply(list, function(nm){
					return nm;
				}, ', ')
			);
		}}

		function manualSection(level, sectTitle, refID, content){with($H){
			if(arguments.length==3){content = refID; refID = null;}
			return div({'class':'section'},
				a({name:'s'+uid()}),
				refID?a({name:refID}):null,
				$H['h'+level]({'class':'title'}, sectTitle),
				div({'class':'navbar'},
					a({'href':'#toc', title:'К оглавлению'}, '&#x2261'), ' ',
					span({'class':'button lnkRoll', href:'#', title:'Свернуть'}, '&#x25B2;')
				),
				div({'class':'sectionContent'},
					content
				)
			);
		}}
		function codesample(lines){with($H){
			return pre({'class':'code'},
				lines instanceof Array?apply(lines, function(ln){return entities(ln)+'\n';})
					:entities(lines)
			);
		}}

		function code(str){
			return $H.span({'class':'code'}, $C.entities(str));
		}

		function attention(str){
			return $H.div({'class':'attention'}, str);
		}

		function comment(str){
			return $H.div({'class':'comment'}, str);
		}

		var errorsDetected = false,
			errors = [];

		function equals(v1, v2){
			if(v1 instanceof Array){
				if(!(v2 instanceof Array)) return false;
				if(v1.length!=v2.length) return false;
				for(var i=0; i<v1.length; i++){if(!equals(v1[i], v2[i])) return false;}
				return true;
			}
			if(typeof(v1)=='object'){
				if(typeof(v2)!='object' || v2 instanceof Array) return false;
				for(var k in v1){if(!equals(v1[k], v2[k])) return false;}
				for(var k in v2){if(!equals(v1[k], v2[k])) return false;}
				return true;
			}
			return v1==v2;
		}

		function assert(val, expected){
			if(!equals(val, expected)){
				errorsDetected = true;
				errors.push('Assertion failed: expected "'+$C.entities(expected)+'", but was "'+$C.entities(val)+'"');
				console.log('Assertion failed: expected %o, but was %o', expected, val);
			}
		}

		function assertTrue(val){
			assert(val, true);
		}
		
		test(function(){
			if(!equals([1,2], [1,2])) console.error('Equation test failed');
			if(equals([1,2], null)) console.error('Equation test failed');
			if(equals([1,2], 2)) console.error('Equation test failed');
			if(equals([1,2], [2])) console.error('Equation test failed');
			if(equals([1,2], {x:1})) console.error('Equation test failed');
			if(equals(null, 3)) console.error('Equation test failed');
			if(!equals(null, null)) console.error('Equation test failed');
			if(!equals({x:2, y:3}, {y:3, x:2})) console.error('Equation test failed');
			if(equals({x:2, y:3}, {x:2})) console.error('Equation test failed');
			if(equals({x:2, y:3}, {y:3})) console.error('Equation test failed');
			if(equals({x:2, y:3}, [3])) console.error('Equation test failed');
			if(!equals({x:2, y:{a:1}}, {y:{a:1}, x:2})) console.error('Equation test failed');
			if(!equals(3, 3)) console.error('Equation test failed');
			if(!equals('abc', 'abc')) console.error('Equation test failed');
			if(!equals(true, true)) console.error('Equation test failed');
			if(equals(null, false)) console.error('Equation test failed');
			if(equals(false, null)) console.error('Equation test failed');
		});

		function test(name, group, action){with($H){
			if(arguments.length==1){
				action = name;
				group = name = '';
			}
			else
				name = $H.format('"{0}:{1}"', group, name);
			errors = [];
			action();
			return errors.length?div({'class':'error'}, 
					name, ' ',
					$C.apply(errors, function(e){return div(e)})
				)
				:showTests?div({'class':'success'}, 'Test ', name, ' performed'):null;
		}}

		function testSample(actionCode, expected){with($H){
			errors = [];
			var F = new Function('return '+actionCode);
			var res = F();
			assert(res, expected);

			return markup(
				span(' вызов ', code(actionCode), ' вернет строку ', code(expected)),
				errors.length?span({'class':'error'}, 
					name, ' ',
					$C.apply(errors, function(e){return div({'class':'error'}, e)})
				)
				:showTests?span({'class':'success'}, 'Test performed'):null

			);
		}}

		var describedFields = {};

		function referenceManual(prefix, root, doc, showRemaining){with($H){
			if(typeof(doc)=='function') doc = doc();
			return table({border:1, cellpadding:3, cellspacing:0, width:pc(100)},
				$C.apply(doc, function(man, fld){
					describedFields[prefix+'.'+fld] = true;
					var itm = root[fld];
					return tr(
						td(
							itm?null
								:(errorsDetected=true,div({'class':'error'}, 'not defined')), prefix, '.',
							fld,
							typeof(itm)=='function'?'()':null
						),
						td(man)
					);
				}),
				showRemaining?$C.apply(root, function(v, fld){
					return describedFields[prefix+'.'+fld]?null:tr(
						td(
							prefix, '.', fld, 
							typeof(root[fld])=='function'?'()':null
						),
						td((errorsDetected=true,div({'class':'error'}, 'нет описания')))
					);
				}):null
			);
		}}

		function skinSelector(){with($H){
			return div({'class':'skinSelector'},
				'Оформление ',
				select(
					apply(Skins, function(s, k){
						return option({value:k}, s.name);
					})
				)
			);
		}}

		function manual(){with($H){
			var markup = $C.markup;
			return div({'class':'manual'},
				h1(Settings.title),
				skinSelector(),
				p('Сайт проекта: ', a({href:'http://github.com/alakim/clarino'}, 'http://github.com/alakim/clarino'), '.'),
				div({'class':'error pnlErrorsDetected'}, 'Обнаружены ошибки'),
				a({name:'toc'}),
				div({'class':'pnlToc'}),
				manualSection(2, 'Назначение', div(
					p('При создании динамических HTML-страничек часто возникает необходимость формирования фрагментов HTML-кода. Попытки решить задачу простой конкатенацией строк даже при небольшом объеме формируемого кода часто заканчиваются неудачей из-за сложности написания, и, тем более, поддержки и модификации полученного кода.'),
					p('Существует множество фреймворков, предлагающих различные механизмы шаблонизации, облегчающие данную задачу. Вместе с тем, у подобных решений имеется ряд недостатков:'),
					ul(
						li('часто использование фреймворка требует полного изменения архитектуры уже существующего веб-приложения, что не всегда возможно;'),
						li('используемый фреймворком язык шаблонизации порой оказывается достаточно примитивным, и реализация достаточно сложных шаблонов оказывается довольно громоздкой.')
					),
					p('Предлагаемый программный модуль Clarino предназначен для формирования фрагментов HTML-, XML-, и CSS-кода на основе шаблонов, полностью написанных на языке JavaScript.'),
					p('Преимуществами данного решения являются:'),
					ul(
						li('компактность данной библиотеки;'),
						li('независимость от сторонних библиотек;'),
						li('легкая интеграция в существующие веб-приложения;'),
						li('возможность использования всех языковых средств JavaScript при создании шаблонов;'),
						li('исключаются многие ошибки при создании шаблонов, связанные с незакрытыми, или "перекрестными" тегами;'),
						li('быстрый старт - нет необходимости изучать новый язык шаблонизации;'),
						li('расширяемость - при необходимости можно дополнять модуль своими определениями;'),
						li('быстродействие - как показал многолетний опыт, использование данного подхода не вызывает проблем даже на очень слабых машинах и очень старых браузерах.')
					)
				)),
				manualSection(2, 'Использование', 'usage', markup(
					manualSection(3, 'Подключение', div(
						p('Для использования библиотеки Clarino достаточно подключить её к веб-странице:'),
						codesample(['<scr'+'ipt src="clarino.js"></sc'+'ript>']),
						test("Подключение модуля Clarino", "Configuration", function(){
							assert(typeof(Clarino), "object");
						}),
						p('Для обеспечения обратной совместимости в модуле предусмотрена проверка текущей версии. Чтобы указать минимальный номер версии, обеспечивающий работу пользовательского кода, следует вызвать метод ', code('Clarino.version()'), ' передав в него минимальный номер версии. Например, так:'),
						codesample('Clarino.version("1.0.2")'),
						test(function(){
							assertTrue(typeof(Clarino.version('0.0.0').version)=='function');
							assertTrue(typeof(Clarino.version('0.0.0').apply)=='function');
						}),
						p('Если подключенная библиотека Clarino поддерживает такую версию, то этот метод возвратит объект, реализующий интерфейс библиотеки заданной версии. В случае, если подключена слишком старая версия библиотеки, в консоль браузера будет выдано сообщение об ошибке.'),
						p('Для получения номера текущей версии библиотеки надо вызвать метод ', code('Clarino.version()'),' без аргументов:'),
						codesample(['Clarino.version()']),
						test(function(){
							assertTrue(Clarino.version().match(/\d+\.\d+\.\d+/)!=null);
						})
					)),
					manualSection(3, 'Простая верстка', div(
						p('Для формирования фрагментов HTML-кода в разделе ', code('Clarino.html'), ' имеются методы, соответствующие HTML-тегам, определенным в стандарте HTML5. Каждый из этих методов преобразует все переданные ему значения в строки, конкатенирует эти строки, и заключает их в соответствующий тег HTML5.'),
						p('Например, ', testSample('Clarino.html.p("abc", "def")', '<p>abcdef</p>'), '.'),
						p('Для удобства, чтобы не указывать каждый раз имя раздела ', code('Clarino.html'), ', можно использовать конструкцию ', code('with(Clarino.html){....}'), '.'),
						p('Если используется режим ', code("'use strict'"), ', следует использовать деструктуризацию, например: ', code('let {div, p, span} = Clarino.html;'), '.'),
						p('Вот пример функции, возвращающей HTML-код со вложенными тегами:'),
						codesample([
							'function(){with(Clarino.html){',
							'	return div(',
							'		p("abc"),',
							'		p("def")',
							'	);',
							'}}'
						]),
						test("Простая верстка", "Верстка", function(){
							with(Clarino.simple){
								assert(
									div(
										p("abc"),
										p("def")
									),
									"<div><p>abc</p><p>def</p></div>"
								);
							}
						}),

						p('Для указания атрибутов HTML-тегов следует в числе аргументов передать объект, атрибуты и значения которого соответствуют требуемым HTML-атрибутам и их значениям:'),
						codesample([
							'function(){with(Clarino.html){',
							'	return div({"class":"test", id:"test1"},',
							'		p("abc"),',
							'		p("def")',
							'	);',
							'}}'
						]),
						attention(markup('В приведенном примере имя атрибута ', code('class'), ' совпадает с зарезервированным ключевым словом JavaScript, поэтому оно обязательно должно быть заключено в кавычки.')),
						test("Простая верстка с атрибутами", "Верстка", function(){
							with(Clarino.simple){
								assert(
									div({
											"class":"panel",
											width:200
										},
										p("abc")
									),
									"<div class=\"panel\" width=\"200\"><p>abc</p></div>"
								);
							}
						}),

						test("Простая таблица", "Верстка", function(){
							with(Clarino.simple){
								assert(
									table({border:0, cellpadding:0, cellspacing:0},
										tr(td("11"), td("12")),
										tr(td("21"), td("22"))
									),
									"<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td>11</td><td>12</td></tr><tr><td>21</td><td>22</td></tr></table>"
								);
							}
						}),

						test("Таблица с пустыми ячейками", "Верстка", function(){
							with(Clarino.simple){
								assert(
									table(
										tr(th("ss"), th("  ")),
										tr(td("11"), td("   ")),
										tr(td(), td("22"))
									),
									"<table><tr><th>ss</th><th>&nbsp;</th></tr><tr><td>11</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>22</td></tr></table>"
								)
							}
						}),

						test("Картинки", "Верстка", function(){
							with(Clarino.simple){
								assert(
									div(
										hr(),
										img({src:"null.gif", width:"10px"}),
										br(),
										p("abc")
									),
									"<div><hr/><img src=\"null.gif\" width=\"10px\"/><br/><p>abc</p></div>"
								);
							}
						}),

						p('Для формирования фрагмента HTML-кода, не окруженного никаким тегом, предусмотрен метод ', code('Clarino.markup'), ':'),
						codesample([
							'Clarino.markup(',
							'	"my photo: "',
							'	Clarino.html.img({src:"photo.jpg"})',
							')'
						]),
						test("tagCollection", "Верстка", function(){
							with(Clarino.simple){
								assert(
									markup(
										div("abc"),
										"def",
										div("ghi")
									),
									"<div>abc</div>def<div>ghi</div>"
								);
							}
						}),
						
						p('При необходимости включения фрагментов верстки по условиям следует использовать условный (тернарный) оператор ', code('condition ? expr1 : expr2'), ' , например:'),
						codesample([
							'function(attention){with($Clarino.html){',
							'	return div(',
							'		attention?{style:"color:red;"}:null,',
							'		"This is ",',
							'		attention?"an important":"a",',
							'		" message"',
							'	);',
							'}}'
						]),
						p('В приведенном примере, в зависимости от значения параметра ', code('attention'), ' при вызове функции будет сформирован следующий код: '),
						ul(
							li(code('<div style="color:red;">This is an important message</div>'), ', если ', code('attention==true')),
							li(code('<div>This is a message</div>'), ', если ', code('attention==false'))
						),
						attention(markup('При формировании HTML-кода значение ', code('null'), ' преобразуется в пустую строку.')),
						test("Arbitrary Attributes", "Верстка", function(){
							with(Clarino.simple){
								var b = true;
								assert(
									div({width:4},
										b?{height:5}:null,
										!b?{"z-index":3}:null,
										"xxx"
									),
									"<div width=\"4\" height=\"5\">xxx</div>"
								);
							}
						}),
						p('При создании простой HTML-верстки могут оказаться полезными вспомогательные методы, описанные в разделе ', a({href:'#formatting'}, 'Форматирование'), ', обеспечивающие простое форматирование значений атрибутов, стилей, и т.п.')
					)),
					manualSection(3, 'Структуры данных и шаблонизация', markup(
						p('При создании фрагментов HTML-верстки, отображающих сложные структуры данных (массивы или объекты), необходимо использование функций ', a({href:'#templating'}, 'шаблонизации'),'.'),
						attention(markup('Для удобства доступа к фукнциям шаблонизации одновременно с часто используемыми тегами HTML предусмотрен специальный ', a({href:'#divisions'}, 'раздел'), ' библиотеки ', code('Clarino.simple'), ', включающий в себя функции шаблонизации, форматирования, а также основные теги HTML.')),
						p('Основной функцией для отображения структур данных является ', a({href:'#clarino_apply'}, ' функция ', 'Clarino.apply()'), '. Функция получает исходную структуру данных, а также функцию-шаблон, применяемую к каждому элементу структуры. Если структура является массивом, в шаблон передается каждый его элемент. Если структура является объектом, в шаблон передаются значение и имя каждого из атрибутов данного объекта.'),
						p('Результаты применения шаблона ко всем элементам исходной структуры соединяются в единую строку. Если требуется разделитель, его можно указать третьим аргументом функции.'),
						p('Допустим, имеется следующая структура данных:'),
						codesample([
							'var db = [',
							'	{name:"John", phone:"444-44-44"},',
							'	{name:"Phill", phone:"222-22-22"},',
							'	{name:"James", phone:"333-33-33"}',
							'];'
						]),
						p('Тогда для вывода этих данных в виде таблицы можно использовать следующую функцию:'),
						codesample([
							'function(db){with(Clarino.simple){',
							'	return table(',
							'		tr(',
							'			th("#"),',
							'			th("Name"),',
							'			th("Phone")',
							'		),',
							'		apply(db, function(el, i){',
							'			return tr(',
							'				td(i+1),',
							'				td(el.name),',
							'				td(el.phone)',
							'			);',
							'		})',
							'	);',
							'}}'
						]),
						p('В первой строке данной таблицы выводятся заголовки столбцов, далее следуют строки, соответствующие элементам исходного массива. В первой колонке выводится порядковый номер, во второй имя, а в третьей - телефонный номер.'),
						p('В случае использования "строгого режима" Javascript ("use strict") следует вместо конструкции ', code('with()'), ' использовать деструктуризацию:'),
						codesample([
							'function(db){',
							'	let {table, tr, th, td} = Clarino.simple;',
							'	return table(',
							'		tr(',
							'			th("#"),',
							'			th("Name"),',
							'			th("Phone")',
							'		),',
							'		apply(db, function(el, i){',
							'			return tr(',
							'				td(i+1),',
							'				td(el.name),',
							'				td(el.phone)',
							'			);',
							'		})',
							'	);',
							'}'
						]),
						comment(markup('Если в шаблоне используется очень много разнообразных тегов, нет смысла перечислять их все в выражении деструктуризации - достаточно указать там только наиболее употребительные, а остальные при необходимости указывать через их полное имя.')),
						p('В следующем примере представлена функция, формирующая таблицу квадратов чисел от 1 до 10:'),
						codesample([
							'function(){with(Clarino.simple){',
							'	return table(',
							'		tr(',
							'			th("x"),',
							'			th("x",  Clarino.html.sup("2"))',
							'		),',
							'		repeat(10, function(x){',
							'				return tr(',
							'					td(x),',
							'					td(x*x)',
							'				);',
							'		})',
							'	);',
							'}}'
						]),
						p('В данном примере кроме тегов из раздела ', code('Clarino.simple'), ' используется довольно редкий тег ', code('sup'), ', расположенный в разделе ', code('Clarino.html'), '.'),
						p('Для работы с шаблоном используется функция ', code('repeat()'), ', применяющая шаблон заданное число раз.'),
						p('В первой строке таблицы выводятся, как обычно, названия столбцов, в остальных - пары значений (исходное число и его квадрат).'),
						test("Таблица", "Шаблоны", function(){
							with(Clarino.simple){
								var data = [{nm:"abc", nr:1}, {nm:"def", nr:2}];
								assert(
									table(
										apply(data, function(el){
											return tr(td(el.nm), td(el.nr))
										})
									),
									"<table><tr><td>abc</td><td>1</td></tr><tr><td>def</td><td>2</td></tr></table>"
								);
							}
						}),

						test("Таблица с раскрашенными строками", "Шаблоны", function(){
							with(Clarino.simple){
								var data = [{nm:"abc", nr:1}, {nm:"def", nr:2}, {nm:"ghi", nr:3}];
								assert(
									table(
										apply(data, function(el, i){
											return tr(i%2?null:{"class":"even"},
												td(el.nm), td(el.nr)
											)
										})
									),
									"<table><tr class=\"even\"><td>abc</td><td>1</td></tr><tr><td>def</td><td>2</td></tr><tr class=\"even\"><td>ghi</td><td>3</td></tr></table>"
								);
							}
						}),

						test("Таблица с заголовком", "Шаблоны", function(){
							with(Clarino.simple){
								var data = [{nm:"abc", nr:1}, {nm:"def", nr:2}];
								assert(
									table({border:0, cellpadding:3, cellspacing:0},
										tr(th("Name"), th("Number")),
										apply(data, function(el){
											return tr(td(el.nm), td(el.nr))
										})
									),
									"<table border=\"0\" cellpadding=\"3\" cellspacing=\"0\"><tr><th>Name</th><th>Number</th></tr><tr><td>abc</td><td>1</td></tr><tr><td>def</td><td>2</td></tr></table>"
								);
							}
						}),

						test("Таблица с источником данных в структуре", "Шаблоны", function(){
							with(Clarino.simple){
								var data = {
									"John":22,
									"Phill":33,
									"George":44
								};
								assert(
									table(
										apply(data, function(val, nm){
											return tr(
												td(nm),
												td(val)
											);
										})
									),
									"<table><tr><td>John</td><td>22</td></tr><tr><td>Phill</td><td>33</td></tr><tr><td>George</td><td>44</td></tr></table>"
								);
							}
						}),

						test("Нумерация", "Шаблоны", function(){
							with(Clarino.simple){
								var data = [{nm:"abc", nr:1}, {nm:"def", nr:2}];
								assert(
									div(
										apply(data, function(el, i){
											return p((i+1)+". "+el.nm);
										})
									),
									"<div><p>1. abc</p><p>2. def</p></div>"
								)
							}
						}),

						test("Нумерация с разделителем", "Шаблоны", function(){
							with(Clarino.simple){
								var data = [{nm:"abc", nr:1}, {nm:"def", nr:2}];
								assert(
									div(
										apply(data, function(el, i){
											return span((i+1)+". "+el.nm);
										}, ", ")
									),
									"<div><span>1. abc</span>, <span>2. def</span></div>"
								)
							}
						}),

						test("Нумерация с разделителем 2", "Шаблоны", function(){
							with(Clarino.simple){
								var data = [1, 2, null, 3, ""];
								assert(
									div(
										apply(data, function(el, i){
											if(el==3) return null;
											return span(el);
										}, ", ", true)
									),
									"<div><span>1</span>, <span>2</span></div>",
									"Error 1"
								)
								assert(
									div(
										apply(data, function(el, i){
											if(el==3) return null;
											return span(el);
										}, ", ", false)
									),
									"<div><span>1</span>, <span>2</span>, <span></span>, , <span></span></div>",
									"Error 2"
								)
							}
						}),

						test("Итерация 1", "Шаблоны", function(){
							with(Clarino.simple){
								assert(
									div(
										repeat(2, function(i){
											return span(i);
										})
									),
									"<div><span>1</span><span>2</span></div>"
								);
							}
						}),

						test("Итерация 2", "Шаблоны", function(){
							with(Clarino.simple){
								assert(
									div(
										p("xyz"),
										repeat(2, function(i){
											return span(i);
										}),
										p("abc")
									),
									"<div><p>xyz</p><span>1</span><span>2</span><p>abc</p></div>"
								);
							}
						}),

						test("Итерация с разделителем", "Шаблоны", function(){
							with(Clarino.simple){
								assert(
									div(
										repeat(2, function(i){
											return span(i);
										}, ", ")
									),
									"<div><span>1</span>, <span>2</span></div>"
								);
							}
						})
					)),
					manualSection(3, 'Форматироване XML', markup(
						p('Библиотека Clariono может быть использована также для создания фрагментов XML-кода. В общих чертах, используется такой же подход, как и к обычной HTML-верстке. Отличие заключается лишь в том, что требуется создание определений для новых тегов.'),
						p('Для объявления новых тегов используется метод ', a({href:'#clarino_gettagdefinitions'}, 'Clarino.getTagDefinitions()'), '.'),
						(function(){
							var defCode = 'Clarino.getTagDefinitions("person;name;phone")';
							var xDef = (new Function('return '+defCode))();
							var xCode = (function(){with(xDef){
								return person(
									name('John'), phone('444-44-44')
								);
							}})();
							var cnt = 0;
							var methodSet = apply(xDef, function(v, nm){
								return markup(
									2==cnt++?'и ':null,
									code(nm+'()')
								);
							}, ', ');
							return markup(
								test(function(){
									assert(typeof(xDef.person), 'function');
									assert(typeof(xDef.name), 'function');
									assert(typeof(xDef.phone), 'function');
									assert(cnt, 3);
								}),
								p(
									'Например, для создания XML-документа ', code(xCode), ' требуется создать следующее определение тегов: ',
									code('var xDef = '+defCode), '. Полученный объект ', code('xDef'),' будет содержать методы ', methodSet, 
									', реализующие форматирование тегов аналогично с рассмотренными выше тегами HTML.'
								)
							);
						})()
					)),
					manualSection(3, 'Создание CSS-таблиц', 'usingCss', markup(
						p('Для создания таблиц стилей используются методы, доступные в разделе ', a({href:'#csstables'}, 'Clarino.css'), '. Данный подход позволяет хорошо структурировать информацию о стилях, используя все возможности языка JavaScript для формирования повторяющихся или обобщенных фрагментов CSS-кода. Кроме того, появляется возможность при создании отдельных программных модулей описывать необходимые базовые стили отображения непосредственно в JavaScript-коде этих модулей без необходимости подключения внешних CSS-файлов.'),
						p('Таблица стилей описывается в виде вложенных JSON-объектов, и передается либо методу ', code('Clarino.css.stylesheet()'), ', который возвращает готовый CSS-код, либо методу ', code('Clarino.css.writeStylesheet()'), ', который формирует тег ', code('<style>'), ', содержащий соответствующий CSS-код, и выводит его непосредственно в поток загружаемого документа с помощью стандартного метода ', code('document.write()'),'.'),
						p('Правила формирования JSON-описания стилей довольно просты:'),
						p('JSON-объект содержит пары "ключ:значение", трактуемые как имя и значение соответствующего свойства CSS. Однако, если значение также является JSON-объектом, то соответствующий ключ трактуется как CSS-селектор.'),
						(function(){
							var srcJson = [
								'{',
								'	"div.attention":{',
								'		margin:"5px",',
								'		color:"#f00"',
								'	}',
								'}'
							];
							var cssRes = [
								'div.attention{',
								'	margin:5px;',
								'	color:#f00;',
								'}'
							];
							var src = (new Function('return '+srcJson.join('')))();
							var css = $C.css.stylesheet(src);
							return markup(
								test(function(){
									assert(
										css.replace(/\s+/gi, ' ').replace(/\s+:\s+/gi, ':').replace(/\s+;/gi, ';').replace(/;\s+}/gi, ';}'), 
										cssRes.join('').replace(/\s+/gi, ' ')
									);
								}),
								p('Например, следующее JSON-определение:'),
								codesample(srcJson),
								p('будет преобразовано в следующую таблицу стилей:'),
								codesample(cssRes)
							);
						})(),
						(function(){
							var srcJson = [
								'{',
								'	"div.mainForm":{',
								'		border:"1px solid #ccc",',
								'		padding: "5px",',
								'		" .name":{',
								'			"font-weight":"bold"',
								'		}',
								'	}',
								'}'
							];
							var cssRes = [
								'div.mainForm{',
								'	border:1px solid #ccc;',
								'	padding:5px;',
								'}',
								'div.mainForm .name{',
								'	font-weight:bold;',
								'}'
							];
							var src = (new Function('return '+srcJson.join('')))();
							var css = $C.css.stylesheet(src);
							return markup(
								test(function(){
									assert(
										css.replace(/\s+/gi, ' ').replace(/\s+:\s+/gi, ':')
											.replace(/\s+;/gi, ';').replace(/;\s+}/gi, ';}')
											.replace('} div', '}div')
										, 
										cssRes.join('').replace(/\s+/gi, ' ')
									);
								}),
								p('Если некоторый JSON-объект вложен в другой, то к его селектору будет добавлен спереди селектор родительского объекта, и т.д. вверх по иерархии. Например, следующее JSON-определение:'),
								codesample(srcJson),
								p('будет преобразовано в следующую таблицу стилей:'),
								codesample(cssRes),
								attention(markup('Следует обратить внимание на пробел перед селектором ', code('" .name"'), ' в исходном коде. Он важен, т.к. влияет на результат конкатенации селекторов: ', code('div.mainForm .name'), ' и ', code('div.mainForm.name'), ' - не одно и то же (см. любой справочник по CSS).'))
							);
						})(),
						p('Если вместо JSON-объекта передается массив, то все содержающиеся в нем CSS-свойства будут представлены в полученной CSS-таблице (подробнее см. описание функции ', a({href:'#css_stylesheet'}, 'Clarino.css.stylesheet()'), ').'),
						p('Для облегчения записи имен свойств CSS, содержащих дефис, допускается записывать их без дефиса, переводя следующую за дефисом букву в верхний регистр. Например, ', code('fontWeight'), ' будет автоматически преобразовано в ', code('font-weight'), '.'),
						p('Для облегчения работы с единицами измерения имеется метод ', a({href:'#clarino_css_unit'}, 'Clarino.css.unit()'), '.'),
						p('Для уменьшения количества строковых констант при создании CSS-таблиц предлагается к использованию словарь ', code('Clarino.css.keywords'), ', содержащий наиболее употребительные строковые значения свойств CSS.'),
						comment('Уменьшение количества строковых констант позволяет снизить нагрузку на сборщик мусора'),
						p(
							'Например, ', testSample('Clarino.css.keywords.none', 'none'), ', ',
							testSample('Clarino.css.keywords.left', 'left'), ', a',
							testSample('Clarino.css.keywords.flexStart', 'flex-start'), '.'
						),
						p('Для упрощения формирования таблиц стилей предусмотрен ряд удобных шаблонов, размещенных в разделе ', a({href:'#csstemplates'},'Clarino.css.template'), '.')
					)),
					manualSection(3, 'Примеры', markup(
						p('Для иллюстрации основных подходов при работе с библиотекой Clarion представлен пример реализации веб-приложения ', a({href:'samples/phonebook/index.html'}, 'Phonebook'), '. Данное приложение включает в себя макет небольшой базы данных, содержащей телефонный справочник, и имитирующей обращение к ней по Ajax. Приложение реализует простые операции просмотра и редактирования справочника. Поскольку приложение не имеет настоящей базы данных (используется лишь макет, написанный на JavaScript), результаты редактирования не сохраняются, и при перезагрузке веб-страницы они будут потеряны. Приложение использует модальные диалоги, а также переключаемые стили отображения.'),
						p('Другим примером использования библиотеки Clarino является настоящее руководство. Раздел "Справочник" формируется динамически на основе анализа текущей версии библиотеки. В настоящее руководство включены модульные тесты библиотеки, запускаемые при каждой загрузке страницы. Каждый приведенный в данном руководстве пример кода проверяется соответствующим тестом.')
					))
				)),
				manualSection(2, 'Справочник', markup(
					manualSection(3, 'Разделы', 'divisions', div(
						p('Для упрощения доступа атрибуты и методы библиотеки Clarino сгруппированы в несколько разделов.'),
						referenceManual('Clarino', $C, { 
							html: markup(
								p('Содержит определения ', a({href:'#htmltags'}, 'HTML-тегов')),
								test(function(){assertTrue(typeof($C.html)=='object');})
							),
							css: markup(
								p('Содержит функции для формирования ', a({href:'#csstables'},'CSS-таблиц')),
								test(function(){assertTrue(typeof($C.css)=='object');})
							),
							simple: markup(
								p('Содержит упрощенный интерфейс для создания простых веб-форм. В этот раздел включены основные методы ', a({href:'#templating'}, 'шаблонизации'), ' и ', a({href:'#formatting'}, 'форматирования'), ', а также определения наиболее часто используемых ', a({href:'#htmltags'}, 'тегов HTML'), '.'),
								test(function(){assertTrue(typeof($C.simple)=='object');}),
								p('Список включенных в этот раздел методов: '),
								listOfMethods($C.simple)
							)
						}),
						p('Корневой раздел модуля ', code('Clarino'), ' содержит функции ', a({href:'#templating'}, 'шаблонизации'), ', ', a({href:'#formatting'}, 'форматирования'), ', а также ряд вспомогательных функций.')
					)),
					manualSection(3, 'HTML-теги', 'htmltags', div(
						p('Определения HTML-тегов размещены в разделе ', code('Clarino.html'), '. Кроме того, наиболее употребительные теги доступны также через раздел ', code('Clarino.simple')),
						referenceManual('Clarino.html', $C.html, function(){
							// https://www.w3schools.com/tags/
							var tags = 'a;abbr;address;area;article;aside;audio;b;base;bdi;bdo;blockquote;body;br;button;canvas;caption;cite;code;col;colgroup;datalist;dd;del;details;dfn;dialog;div;dl;dt;em;embed;fieldset;figcaption;figure;footer;form;h1;h2;h3;h4;h5;h6;head;header;hr;html;i;iframe;img;input;ins;kbd;keygen;label;legend;li;link;main;map;mark;menu;menuitem;meta;meter;nav;nobr;noscript;object;ol;optgroup;option;output;p;param;picture;pre;progress;q;rp;rt;ruby;s;samp;script;section;select;small;source;span;strong;style;sub;summary;sup;svg;table;tbody;td;textarea;tfoot;th;thead;time;title;tr;track;u;ul;var;video;wbr'.split(';');
							var tagDefs = {};
							for(var t,i=0; t=tags[i],i<tags.length; i++){
								tagDefs[t] = markup(
									p($C.entities('Формирует HTML-тег <'+t+'>')),
									test(function(){
										var f = $C.html[t];
										assertTrue(typeof(f)=='function' && f('x')=='<'+t+'>x</'+t+'>');
									})
								);
							}
							return tagDefs;
						})
					)),
					manualSection(3, 'Шаблонизация', 'templating', div(
						referenceManual('Clarino', $C, {
							apply: markup(
								a({name:'clarino_apply'}),
								p('Применяет шаблон к элементам массива или полям объекта. Начиная с версии 1.4.0 поддерживаются также коллекции на основе Map и Set.'),
								p('Входные параметры: ', code('Clarino.apply(collection, template, separator)')),
								ol(
									li($C.html.b('collection'), ' - исходная структура данных (массив или объект)'),
									li($C.html.b('template'), ' - функция-шаблон, применяемая ко всем элементам исходной структуры. Шаблон получает значение текущего элемента, а также его индекс в массиве (или имя соответствующего атрибута в объекте)'),
									li($C.html.b('separator'), ' (необязательный) - разделитель, вставляемый между результатами применения шаблона')
								),
								p('Примеры: '),
								ul(
									li(testSample('Clarino.apply([1,2,3], function(x, i){return Clarino.html.span(i,":", x);})', '<span>0:1</span><span>1:2</span><span>2:3</span>'), ';'),
									li(testSample('Clarino.apply([1,2,3], function(x){return Clarino.html.span(x);}, ", ")', '<span>1</span>, <span>2</span>, <span>3</span>'), ';'),
									li(testSample('Clarino.apply({x:2, y:3}, function(v,nm){return Clarino.html.span(Clarino.html.b(nm), ":", v);})', '<span><b>x</b>:2</span><span><b>y</b>:3</span>'), '.')
								)
							),
							repeat: markup(
								p('Применяет шаблон указанное число раз'),
								p('Входные параметры: ', code('Clarino.repeat(count, template, separator)')),
								ol(
									li($C.html.b('count'), ' - количество итераций'),
									li($C.html.b('template'), ' - функция-шаблон, применяемая на каждой итерации. Получает текущий номер итерации, исчисляемый начиная с единицы.'),
									li($C.html.b('separator'), ' (необязательный) - разделитель, вставляемый между результатами применения шаблона')
								),
								p('Например, ',
									testSample('Clarino.repeat(4, function(n){return Clarino.html.span(n);}, ";")', '<span>1</span>;<span>2</span>;<span>3</span>;<span>4</span>'), '.'
								)
							),
							markup: markup(
								p('Контейнер для произвольного набора тегов, не формирующий для них родительский тег.'),
								p('Например, ',
									testSample('Clarino.markup("abc", Clarino.html.span("def"))', 'abc<span>def</span>'), '.'
								)
							)
						})
					)),
					manualSection(3, 'Настройка', div(
						referenceManual('Clarino', $C, {
							version: markup(
								p('Получает минимальную версию библиотеки, необходимую для функционирования пользовательского кода. Возвращает объект, реализующий интерфейс библиотеки заданой версии.'),
								codesample(['var $C = Clarino.version("1.0.2");']),
								p('При вызове без аргументов возвращает текущую версию модуля.')
							),
							compareVersions:markup(
								p('Сравнивает номера версий. Получает два номер версии, возвращает 0, если номера одинаковые, 1, если первый номер больше, и -1, если второй номер больше.'),
								test("compareVersions", "Configuration", function(){
									assert(Clarino.compareVersions("1.2.3", "1.2.3"), 0);
									assert(Clarino.compareVersions("2.2.3", "1.2.3"), 1);
									assert(Clarino.compareVersions("1.2.3", "2.2.3"), -1);
									assert(Clarino.compareVersions("1.3.3", "1.2.3"), 1);
									assert(Clarino.compareVersions("1.2.3", "1.3.3"), -1);
									assert(Clarino.compareVersions("1.2.4", "1.2.3"), 1);
									assert(Clarino.compareVersions("1.2.3", "1.2.4"), -1);
												
									assert(Clarino.compareVersions("2.0.9", "2.0.9"), 0);
									assert(Clarino.compareVersions("2.0.10", "2.0.10"), 0);
												
									assert(Clarino.compareVersions("2.0.10", "2.0.9"), 1, "Err 1");
									assert(Clarino.compareVersions("2.0.9", "2.0.10"), -1, "Err 2");
								})
							),
							xhtmlMode: markup(
								p('Устанавливает режим форматирования XHTML. В таком режиме все теги, не имеющие внутренних тегов или текста, будут принудительно закрыты, как это предусматривается форматом XML. Т.е. тег ', code('<img src="photo.jpg">'), ' будет выглядеть следующим образом: ', code('<img src="photo.jpg"/>'), '.')
							),
							extend: markup(
								p('Добавляет поля к существующему объекту. Получает модифицируемый объект и объект, содержащий добавляемые поля.'),
								p('Например, если имеется объект ', code('var obj = {x:3};'), ' , то вызов ', code('Clarino.extend(obj, {y:"abc"});'), ' приведет исходный объект к следующему виду:', code('{x:3, y:"abc"}'), '.'),
								test(function(){
									var obj = {x:3};
									$C.extend(obj, {y:'abc'});
									assert(obj, {x:3, y:'abc'});
								})
							),
							composeInterface: markup(
								p('Создает интерфейсный объект из полей и методов Clarino. Используется для создания упрощенных интерфейсов.'),
								p('Получает массив путей к элементам Clarino, которые должны быть включены в новый объект. Вместо массива можно передавать строку, состоящую из путей, разделенных точкой с запятой.'),
								p('Пример:'),
								codesample([
									'var simple = Clarino.composeInterface("version;apply;html.p.html.div");'
								]),
								p('В результате будет получен объект ', code('simple'), ', содержащий методы ', code('version'), ', ', code('apply'), ', ', code('p'), ', и ', code('div'), '.'),
								test(function(){
									var obj = $C.composeInterface('version;apply;html.p;html.div');
									assertTrue(obj.version && typeof(obj.version)=='function' && obj.version()==$C.version());
									assertTrue(obj.apply!=null && typeof(obj.apply)=='function');
									assertTrue(obj.p && typeof(obj.p)=='function');
									assertTrue(obj.div && typeof(obj.div)=='function');
									obj = $C.composeInterface(['version','apply']);
									assertTrue(obj.version && typeof(obj.version)=='function' && obj.version()==$C.version());
									assertTrue(obj.apply!=null && typeof(obj.apply)=='function');
								}),
								test('OldComposition', 'Settings', function(){
									const $C = Clarino.version('2.0.0');
									obj = $C.compose(['version','apply']);
									assertTrue(obj.version && typeof(obj.version)=='function' && obj.version()==$C.version());
									assertTrue(obj.apply!=null && typeof(obj.apply)=='function');
								})
							)
						})
					)),
					manualSection(3, 'Форматирование', 'formatting', div(
						referenceManual('Clarino', $C, {
							tag: markup(
								p('Создает фрагмент разметки с произвольным тегом. Функции передается имя тега, и массив размещаемых в нем значений.'),
								p('Например, ', 
									testSample('Clarino.tag("a", ["abc"])', '<a>abc</a>'), '.'
								),
								test(function(){
									assert(Clarino.tag('a', ['abc']), '<a>abc</a>');
								})
							),
							formatStyle: markup(
								p('Форматирует строку стилей для размещения в атрибуте HTML-элемента. Значения CSS-атрибутов передаются в виде JSON-объекта. Для ряда атрибутов числовые значения без указания единиц измерения автоматически переводятся в пиксели.'),
								p('Например, следующий вызов'),
								codesample([
									'Clarino.formatStyle({',
									'	width:"100%",',
									'	height:80,',
									'	color:"#f00"',
									'});'
								]),
								p('вернет строку ', code('width:100%;height:80px;color:#f00'), '.'),
								test("Style attribute", "Formatting", function(){ with(Clarino.simple){
									var style = Clarino.formatStyle({
										width:Clarino.css.unit.pct(100),
										height:80,
										color:"#f00"
									});
									assert(style, "width:100%;height:80px;color:#f00");
								}}),
								p('Для сокращения записи допускается имена CSS-атрибутов, содержащие дефис, указывать без дефиса, заменяя при этом регистр следующей за ним буквы на верхний.'),
								p('Например, ',
									testSample('Clarino.formatStyle({fontSize:12})', 'font-size:12px'), '.'
								)
							),
							format: markup(
								p('Форматирование строки со вставкой значений'),
								p('Например, ', testSample('Clarino.format("abc{0}def{1}ghi", 1, 2)', 'abc1def2ghi'), '.'),
								test("format function", "Formatting", function(){ with(Clarino.simple){
									assert(format("abc{0}def", 1), "abc1def");
									assert(format("abc '{0}' def", 1), "abc '1' def");
									assert(format("abc{0}def{1}xxx{2}yyy", 1, "abc", true), "abc1defabcxxxtrueyyy");
								}})
							),
							entities: markup(
								p('Заменяет символы, не допустимые в HTML- или XML-разметке на соответствующие сущности (entity)'),
								p('Например, ', testSample('Clarino.entities("a<b")', 'a&lt;b'), '.'),
								test('Entities function', 'Formatting', function(){with(Clarino.simple){
									assert(entities('a<b'), 'a&lt;b'),
									assert(entities('<p>xxx</p>'), '&lt;p&gt;xxx&lt;/p&gt;');
									assert(entities('<p>xxx&yyy "aaa" \'b</p>'), '&lt;p&gt;xxx&amp;yyy &quot;aaa&quot; &apos;b&lt;/p&gt;');
								}})
							),
							decodeEntities:markup(
								p('Преобразует коды HTML-сущностей в соответствующие символы.'),
								p('Например: ', testSample('Clarino.decodeEntities("a&lt;b")', 'a<b'), '.'),
								test('Decoding entities', 'Formatting', function(){with(Clarino.simple){
									assert(decodeEntities('a&lt;b'), 'a<b');
									assert(decodeEntities('a&lt;b&gt;c'), 'a<b>c');
									assert(decodeEntities('&amp;a&lt;b&gt;c'), '&a<b>c');
									assert(decodeEntities('&quot;a&lt;b&gt;c&apos;'), '"a<b>c\'');
								}})
							),
							callFunction: markup(
								p('Формирует строку вызова функции для привязки обработчика события к HTML-элементу'),
								p('При вызове передаются имя вызываемой функции, и список ее аргументов.'),
								p('Например, ', testSample('Clarino.callFunction("myFunction", 1, "abc", [1,2,3], {x:1, y:2, name:"abba"})', "myFunction(1,'abc',[1,2,3],{x:1,y:2,name:'abba'})"), '.'),
								test("callFunction function", "Formatting", function(){ with(Clarino.simple){
									assert(callFunction("alert", 1), "alert(1)");
									assert(callFunction("alert", "abc"), "alert('abc')");
									assert(callFunction("alert", "ОАО \"Персей\""), "alert('ОАО \\\"Персей\\\"')");
									assert(callFunction("alert", true), "alert(true)");
									assert(callFunction("myFunction", 1, "abc", [1,2,3], {x:1, y:2, name:"abba"}), "myFunction(1,'abc',[1,2,3],{x:1,y:2,name:'abba'})");
									assert(callFunction("clickLink", 12, "@this"), "clickLink(12,this)");
									
								}}),

								test("callFunction function 2", "Formatting", function(){ with(Clarino.simple){
									var idx = 1;
									var id = 2;
									var name="ОАО \"Персей\"";
									assert(
										span({"class":"TEditLinkButton", onclick:callFunction("action", idx, id, name)}, name),
										"<span class=\"TEditLinkButton\" onclick=\"action(1,2,'ОАО \\\"Персей\\\"')\">ОАО \"Персей\"</span>"
									);
								}})
							),
							json: markup(
								p('Сериализует заданный объект в строку JSON'),
								test("JSON serialization", "Formatting", function(){ with(Clarino.simple){
									assert(Clarino.json(1), "1", "Error 1.1");
									assert(Clarino.json(11), "11", "Error 1.2");
									
									assert(Clarino.json(true), "true", "Error 2.1");
									assert(Clarino.json(false), "false", "Error 2.2");
									
									assert(Clarino.json(""), "''", "Error 3.1");
									assert(Clarino.json("abc def"), "'abc def'", "Error 3.1");
									assert(Clarino.json("1234"), "'1234'", "Error 3.1");
									
									assert(Clarino.json(function(){}), "", "Error 4.1");
									
									assert(Clarino.json([]), "[]", "Error 5.1");
									assert(Clarino.json([1]), "[1]", "Error 5.2");
									assert(Clarino.json([1,2,"xx"]), "[1,2,'xx']", "Error 5.3");
									assert(Clarino.json([1,2,{x:1,y:2}]), "[1,2,{x:1,y:2}]", "Error 5.4");
								}})
							)
						})
					)),
					manualSection(3, 'Объявления', 'definitions', div(
						referenceManual('Clarino', $C, {
							defineTags: markup(
								p('Создает дополительные определения тегов в разделе Clarino.html.'),
								p('Получает строку, содержащую имена тегов, разделенных точкой с запятой.'),
								p('Для тегов со сложными именами (например, когда имя тега содержит ссылку на пространство имен) можно задавать алиасы, указывая их перед именем, отделяя вертикальной чертой: ', code('row|xs:row'), '.'),
								test("Tag Definitions", "Extensions", function(){ with(Clarino.simple){
									Clarino.defineTags("ss;ssl;xx|xs:xx");
									var html = (function(){with(Clarino.html){
										return ss(
											ssl("abc"),
											ssl("def"),
											xx(22),
											p("ghi")
										);
									}})();
									assert(html, "<ss><ssl>abc</ssl><ssl>def</ssl><xs:xx>22</xs:xx><p>ghi</p></ss>");
									delete Clarino.html.ssl;
									delete Clarino.html.ss;
									delete Clarino.html._interface;
								}})
							),
							getTagDefinitions: markup(
								a({name:'clarino_gettagdefinitions'}),
								p('Получает строку, содержащую имена определяемых тегов, разделенные точками с запятой'),
								p('Возвращает объект, содержащий методы, соответствующие определяемым тегам.'),
								p('Для тегов со сложными именами (например, когда имя тега содержит ссылку на пространство имен) можно задавать алиасы, указывая их перед именем, отделяя вертикальной чертой: ', code('row|xs:row'), '.'),
								test("Document type definition", "XML", function(){ with(Clarino.simple){
									var xml = (function(){with(Clarino.getTagDefinitions("library;book")){
										return library(
											book({title:"Война и мир"}),
											book({title:"Капитанская дочка"})
										);
									}})();
									assert(xml, "<library><book title=\"Война и мир\"/><book title=\"Капитанская дочка\"/></library>");
								}}),
								test("Document type definition 2", "XML", function(){ with(Clarino.simple){
									var xml = (function(){with(Clarino.getTagDefinitions(["library", "book"])){
										return library(
											book({title:"Война и мир"}),
											book({title:"Капитанская дочка"})
										);
									}})();
									assert(xml, "<library><book title=\"Война и мир\"/><book title=\"Капитанская дочка\"/></library>");
								}}),
								test('Document type definition 3', 'XML', function(){
									var xDef = Clarino.getTagDefinitions('data;row|xs:row');
									var xml = xDef.data(
										xDef.row('abc')
									);
									assert(xml, '<data><xs:row>abc</xs:row></data>');
								})
							),
							symbols: markup(
								p('Создает структуру для хранения строковых констант.'),
								p('Аргументы:'),
								ol(
									li('str - строка, содержащая список строковых констант, разделенных точками с запятой'),
									li('camelCaseToHyphens - (необязательный), устанавливает преобразование заглавных букв в строчные, предваряя их дефисом (по умолчанию false)')
								),
								p('Метод получает строку, содержащую список строковых констант, разделенных точками с запятой. Возвращает объект, имеющий атрибуты, имена и значения которых соответствуют указанным при вызове строковым константам. При этом, если установлен режим camelCaseToHyphens и имена символов содежат заглавные буквы, в значениях символов они будут заменены на строчные, и перед ними будет стоять дефис. При этом имена символов, начинающиеся с заглавной буквы не допускаются.'),
								p('Например, вызов ', code('Clarino.symbols("abc;def;gHi", true)'), ' возвратит объект ', code('{abc:"abc", def:"def", gHi:"g-hi"}'), '.'),
								p('Однако, вызов ', code('Clarino.symbols("abc;def;gHi")'), ' возвратит объект ', code('{abc:"abc", def:"def", gHi:"gHi"}'), '.'),
								test('Symbols', 'Definitions', function(){
									const ss = Clarino.symbols('abc;def;gHi', true);
									assert(ss, {abc:'abc', def:'def', gHi:'g-hi'});
								}),
								test('Camel Case Symbols', 'Definitions', function(){
									const ss = Clarino.symbols('abc;def;gHi');
									assert(ss, {abc:'abc', def:'def', gHi:'gHi'});
								}),
								test('Undefined symbols', 'Definitions', function(){
									assert(Clarino.css.keywords.bold, 'bold');
									try{
										const ss = Clarino.css.keywords.boldx;
									}
									catch(e){
										assert(e, 'Undefined symbol "boldx"');
									}
								}),
								test('Old symbols', 'Definitions', function(){
									const ss = Clarino.version('2.2.0').symbols('abc;def;gHi');
									assert(ss, {abc:'abc', def:'def', gHi:'g-hi'});
								})
							),
							enumeration: markup(
								p('Возвращает объект, содержащий определение перечислимого типа. Атрибуты объекта - идентификаторы значений типа, значения этих атрибутов являются целочисленными константами или символами.'),
								p('Метод получает строку, содержащую список идентификаторов значений, разделенных точками с запятой, а также необязательный параметр ', code('symbolic'), ' (по умолчанию ', code('false'), '), предписывающий использовать в качестве значений атрибутов символы (по умолчанию используются целочисленные константы).'),
								p('Например, вызов ', code('Clarino.enumeration("trumpet;clarinet;flute")'), ' возвратит объект ', code('{trumpet:0, clarinet:1, flute:2}'), '.'),
								test('Enumeration', 'Definitions', function(){
									const en = Clarino.enumeration('trumpet;clarinet;flute');
									assert(en, {trumpet:0, clarinet:1, flute:2});
									en.trumpet = 22;
									assert(en, {trumpet:0, clarinet:1, flute:2});
								}),
								p('Возвращаемый объект является "замороженным" ("frozen"), и не позволяет изменять значения его атрибутов.'),
								test('Undefined enumeration value', 'Definitions', function(){
									const en = Clarino.enumeration('trumpet;clarinet;flute');
									assert(en.trumpet, 0);
									try{
										const trpt = en.boldx;
									}
									catch(e){
										assert(e, 'Undefined enum value "boldx"');
									}
								})
							),
							curry: markup(
								p('Модифицирует функцию, приводя ее в "каррированный" вид, допускающий ее частичное применение.'),
								p('Например, функцию, определенную следующим образом, ', code('const f = Clarino.curry((a,b,c)=>a+b+c);'), ',  можно вызывать разными способами:'),
								ul(
									li(code('f(1,2,3)')),
									li(code('f(1)(2,3)')),
									li(code('f(1,2)(3)')),
									li(code('f(1)(2)(3)'))
								),
								test('Curry', 'Definitions', function(){
									const f = Clarino.curry((a,b,c)=>a+b+c);
									assert(f(1)(2)(3), 6);
									assert(f(1)(2,3), 6);
									assert(f(1, 2)(3), 6);
									assert(f(1,2,3), 6)
								})
							),
							compose: markup(
								p('Формирует функцию, реализующую композицию данных функций. Например, функция ', code('x=>compose(f,g)(x)'), ' эквивалентна функции ', code('x=>f(g(x))'), '.'),
								test('Compose', 'Definitions', function(){
									const f = x=>x*2, g = x=>x+3;
									assert(Clarino.compose(f,g)(4), 14);
									assert(Clarino.compose(g,f)(4), 11);
								})
							),
							pipe: markup(
								p('Формирует функцию, реализующую конвейер данных функций. Например, функция ', code('x=>pipe(f,g)(x)'), ' эквивалентна функции ', code('x=>g(f(x))'), '.'),
								test('pipe', 'Definitions', function(){
									const f = x=>x*2, g = x=>x+3;
									assert(Clarino.pipe(f,g)(4), 11);
									assert(Clarino.pipe(g,f)(4), 14);
								})
							),
							range: markup(
								p('Возвращает функцию-генератор, создающую массив значений, лежащих в заданном диапазоне.'),
								p('Метод получает три аргумента:'),
								ol(
									li(code('vFrom'), ' - указывает начало диапазона'),
									li(code('vTo'), ' - указывает конец диапазона'),
									li(code('vStep'), ' - (необязательный, по умолчанию равен 1), задает шаг следования значений')
								),
								p('Например, вызов ', code('Array.from(Clarino.range(0,4))'), ' возвратит массив ', code('[0, 1, 2, 3, 4]'), '.'),
								test('Range', 'Definitions', function(){
									assert(Array.from(Clarino.range(0,4)), [0,1,2,3,4]);
								})
							),
							lazy: markup(
								p('Модифицирует функцию для придания ей "ленивого" поведения.'),
								p('Получает функцию, возвращает функцию, вызывающую переданную, но отклонающую вызовы, производимые чаще заданного периода.'),
								p('Аргументы: '),
								ol(
									li(code('F'), ' - модифицируемая функция'),
									li(code('timeout'), ' - (необязательный) таймаут в миллисекундах, в течение которого повторные вызовы данной функции отклоняются (по умолчанию равен 300)'),
								),
								p('Данный метод полезен при создании интерактивных веб-форм, основанных на событийной модели. "Ленивое" поведение обработчиков событий предотвращает неоправданно частое их исполнение (например, повторную перерисовку формы в интервале 200 мсек).')
							),
							indexedArray: markup(
								p('Создает прокси-объект, реализующий функциональность индексируемого массива'),
								p('Аргументы:'),
								ol(
									li(code('data'), ' - исходный массив'),
									li(code('idxDef'), ' - объект, содержащий определения индексов. Ключи объекта - идентификаторы индексов, соответствующие значения - функции, возвращающие ID элемента массива, по которому будет происходить индексирование. Значение ID может быть любого типа. Если формируется только один индекс, можно вместо данного объекта просто передать функцию, возвращающую ID.'),
								),
								p('Доступ к элементу массива возможен как по номеру элемента (как в обычном массиве), так и по индексу (как в ассоциативном массиве), для этого используется метод ', code('index(idxVal, idxID)'), '.'),
								p('При добавлении нового элемента он автоматически индексируется. Если элемент с данным ID уже существует в индексе, выбрасывается исключение.'),
								p('Дополнительные свойства и методы:'),
								ul(
									li(code('index(id, idxID)'), ' - метод, возвращающий элемент с заданным индексом. Аргументы: id - ID элемента, занесенное в индекс; idxID - идентификатор индекса, из котогоро будет извлекаться значение (если формируется только один индекс, данный аргумент не обязательный, и по умолчанию имеет значение "id").'),
									li(code('data'), ' - свойство, возвращающее "чистый" массив элементов')
								),
								test('Indexed array', 'Definitions', function(){
									const data = [
										{code:25, name:'abc'},
										{code:28, name:'def'},
										{code:5, name:'ghi'}
									];
									const iarr = Clarino.indexedArray(data, x=>x.code);
									assert(iarr[0].name, 'abc');
									assert(iarr.index(25).name, 'abc');
									iarr.push({code:8, name:'xxx'});
									assert(iarr[3].name, 'xxx');
									assert(iarr.index(8).name, 'xxx');
									try{
										iarr.push({code:8, name:'yyy'});
									}catch(e){
										assert(e, 'Item with ID=8 already exists');
									}
									assert(iarr.index(8).name, 'xxx');
									try{
										iarr.push({name:'zzz'});
									}catch(e){
										assert(e, "Item id can't be null");
									}
									// assert(JSON.stringify(iarr)=='wwww');
									assert(iarr.length, 4);
									assert(iarr.map(x=>x.name).join(';'), 'abc;def;ghi;xxx');

									try{
										iarr.index();
									}catch(e){
										assert(e, "Item id can't be null");
									}

									assert(iarr.data.length, 4);
									assert(JSON.stringify(iarr.data), '[{"code":25,"name":"abc"},{"code":28,"name":"def"},{"code":5,"name":"ghi"},{"code":8,"name":"xxx"}]');
									const x = iarr.pop();
									assert(x.name, 'xxx');
									assert(iarr.map(x=>x.name).join(';'), 'abc;def;ghi');
									assert(iarr.index(8), null);

									iarr.unshift({code:11, name:'www'});
									assert(iarr.map(x=>x.name).join(';'), 'www;abc;def;ghi');
									assert(iarr.index(11).name, 'www');
									
									assert(Array.from(iarr.keys()), [0,1,2,3]);

									const xx = iarr.shift();
									assert(xx.name, 'www'),
									assert(iarr.map(x=>x.name).join(';'), 'abc;def;ghi');
									assert(iarr.index(11), null);

									const ddd = iarr.splice(1, 1, {code:54, name:'qqq'});
									assert(ddd[0].name, 'def');
									assert(iarr.map(x=>x.name).join(';'), 'abc;qqq;ghi');
									assert(iarr.index(28), null);
									assert(iarr.index(54).name, 'qqq');

								}),
								test('Multi Indexed array', 'Definitions', function(){
									const data = [
										{x:1, y:3, n:'abc'},
										{x:2, y:2, n:'def'},
										{x:3, y:1, n:'ghi'}
									];
									const iarr = Clarino.indexedArray(data, {
										x:e=>e.x,
										y:e=>e.y
									});
									assert(iarr.length, 3);
									assert(iarr.index(2, 'x').n, 'def');
									assert(iarr.index(3, 'y').n, 'abc');
								})
							),
							form: markup(
								p('Конструктор интерактивной формы.'),
								p('Аргументы: '),
								ul(
									li(code('container'), ' - контейнерный элемент DOM, в котором будет размещена форма. Задается ссылкой на элемент, или строкой-селектором.'),
									li(code('markup'), ' - строка, содержащая HTML-разметку формы'),
									li(code('events'), ' - (необязательный) структура (объект), содержащая обработчики событий, назначаемые элементам формы')
								),
								p('Структура обработчиков событий представляет собой объект, включающий в себя атрибуты двух уровней. Атрибуты первого уровня имеют в качестве имен селекторы элементов формы. Атрибуты второго уровня имеют именами идентификаторы событий, а в качестве их значений передаются функции-обработчики данных событий.'),
								p('Например, вызов ', code('Clarino.form("#myForm", Clarino.html.button({"class":"bt1"}, "Click me"), {".bt1":{click:function(){console.log("clicked");}}})'), ' создаст в контейнере с идентификатором ', code('myForm'), ' кнопку, по клике на которой будет выводиться сообщение в консоль'),
								test('Form', 'Definitions', function(){
									Clarino.form("#myForm",
										Clarino.html.button({"class":"bt1"}, "Click me"),
										{".bt1":{click:function(){console.log("clicked");}}}
									);
								})
							)
						})
					)),
					manualSection(3, 'CSS', 'csstables', div(
						referenceManual('Clarino.css', $C.css, {
							stylesheet: markup(
								a({name:'css_stylesheet'}),
								p('Формирует фрагмент CSS-кода. Получает JSON-структуру, содержащую описание стилей. Возвращает соответствующий CSS-код.'),
								p('В качестве аргумента можно передать и просто строку CSS-кода, тогда функция просто возвратит ее.'),
								p('Пример входной структуры:'),
								codesample([
									'"body":{',
									'	"font-family":"Verdana"',
									'	fontSize: "12px"',
									'	" p":{',
									'		margin: 0',
									'	}',
									'}'
								]),
								p('Общие правила:'),
								ul(
									li('Если значение атрибута является объектом, то соответствующий ключ (имя атрибута) содержит CSS-селектор.'),
									li('Если значение атрибута строка или число, то ключ является именем CSS-свойства. Если имя свойства содержит дефис, то допускается для сокращения записывать это имя слитно без дефисов, начиная каждую часть имени с заглавной буквы (см. пример выше).'),
									li('Вложенные селекторы конкатенируются. Так в приведенном выше примере из селекторов ', code('body'), ' и ', code(' p'), ' будет составлен селектор ', code(' "body p"'), '. В данном случае важен пробел перед вторым селектором.'),
									(function(){
										var src = [
											'{',
											'	"div.attention":{',
											'		background: [',
											'			"red",',
											'			"-webkit-linear-gradient(left, red , yellow)",',
											'			"-moz-linear-gradient(right, red, yellow)"',
											'		]',
											'	}',
											'}'
										].join('\n');
										var expect = [
											'div.attention{',
											'	background: red;',
											'	background: -webkit-linear-gradient(left, red , yellow);',
											'	background: -moz-linear-gradient(right, red, yellow);',
											'}'
										].join('\n');
										var srcJson = (new Function('return '+src))();
										var sst = Clarino.css.stylesheet(srcJson);
										return markup(
											li('Если значение атрибута является массивом, все содержащиеся в нем значения CSS-свойства выводятся под одним именем, например, для следующего описания стилей:'),
											test(function(){
												var ee = expect.replace(/\s+/gi, ''),
													ss = sst.replace(/\s+/gi, '');
												assert(ss, ee);
											}),
											codesample(src),
											p('будет сформирована следующая CSS-таблица:'),
											codesample(expect)
										);
									})()
								),
								test("Stylesheet", "Extensions", function(){
									var sst = Clarino.css.stylesheet({
										"body":{
											"font-family":"Verdana",
											fontSize:"12px",
											" p":{
												margin:0
											}
										}
									});
									assert(sst, "body{\nfont-family : Verdana ;\nfont-size : 12px ;\n}\nbody p{\nmargin : 0 ;\n}");
								}),
								test("Stylesheet sting", 'Extensions', function(){
									var sst = 'body{color:#fff;}';
									assert(Clarino.css.stylesheet(sst), sst);
								})
							),
							writeStylesheet: markup('Формирует строку CSS-кода с помощью метода ', code('Clarino.css.stylesheet'), ', и выводит ее в поток загружаемого документа.'),
							addStylesheet: markup(
								p('Добавляет блок CSS-кода в конец заголовочного раздела страницы.'),
								p('Входные параметры:'),
								ol(
									li($C.html.b('id'), ' - идентификатор, присваиваемый блоку CSS-кода (если блок с таким ID уже существует, никаких действий не производится)'),
									li($C.html.b('styles'), ' - строка CSS-кода или структура, содержащая описание стилей, аналогичная используемым в методах ', code('Clarino.css.stylesheet'), ' и ', code('Clarino.css.writeStylesheet'), '.')
								)
							),
							updateStylesheet: markup(
								p('Аналогично методу ', code('Clarino.css.addStylesheet'), ' добавляет блок CSS-кода. Если блок с таким ID уже существует, обновляет его содержимое.'),
								p('Входные параметры:'),
								ol(
									li($C.html.b('id'), ' - идентификатор блока CSS-кода (если такой блок уже существует, его содержимое обновляется)'),
									li($C.html.b('styles'), ' - структура, содержащая описание стилей, аналогичная используемым в методах ', code('Clarino.css.stylesheet'), ' и ', code('Clarino.css.writeStylesheet'), '.')
								)
							),
							unit: markup(
								a({name:'clarino_css_unit'}),
								p('Получает наименование единицы измерения, возвращает метод, добавляющий к числам наименование данной единицы.'),
								p('Например, ',
									testSample('Clarino.css.unit("vw")(50)', '50vw'), ', ',
									testSample('Clarino.css.unit("vw")(50, 20)', '50vw 20vw'), ', а ',
									testSample('Clarino.css.unit("px")(120, "auto")', '120px auto'), '.'
								),
								test("Units", "Extensions", function(){
									var px = Clarino.css.unit("px");
									assert(px(22), "22px");
									assert(px(3, 5, 10), "3px 5px 10px");
									assert(Clarino.css.unit.px(22), '22px');
									assert(Clarino.css.unit.pct(100), '100%');
									assert(Clarino.css.unit.px(22, Clarino.css.keywords.auto), '22px auto');
								}),
								test('OldUnits', 'Extensions', function(){
									let $C = Clarino.version('1.5.0');
									assert($C.css.unit.pc(100), '100%');
									assert($C.css.unit('xx')(2,3), '2xx 3xx');
									$C = Clarino.version('1.3.0');
									assert($C.css.unit.pc(100), '100%');
									assert($C.css.unit('xx')(2,3), '2xx 3xx');
									$C = Clarino.version('2.0.0');
									assert($C.css.unit.pc(100), '100pc');
									assert($C.css.unit('xx')(2,3), '2xx 3xx');
								}),
								(function(){
									var units = [];
									for(var k in Clarino.css.unit){
										units.push(k);
									}
									units.sort();
									var nms = {px:'px', em:'em', pc:'pc', rem:'rem', pct:'%'};
									return markup(
										p('Имеется ряд предопределенных единиц:'),
										ul(apply(units, function(u){
											return li(
												code('Clarino.css.unit.'+u+'()'), 
												testSample('Clarino.css.unit.'+u+'(5)', '5'+nms[u])
											);
										}))
									);
								})()
							),
							keywords: markup(
								p('Объект, содержащий строковые константы, соответствующие ключевым словам CSS.'),
								p('Доступ к константам осуществляется по ключу, совпадающему с требуемым строковым значением. Если строковое значение содержит дефис, то при формировании ключа он опускается, а следующая за ним буква заменяется на заглавную.'),
								p('Например, ', 
									testSample('Clarino.css.keywords.none', 'none'), ', ',
									testSample('Clarino.css.keywords.absolute', 'absolute'), ', а ',
									testSample('Clarino.css.keywords.spaceBetween', 'space-between'), '.'
								)
							),
							template: markup(
								a({name:'csstemplates'}),
								p('Содержит ряд шаблонов для формирования фрагментов CSS-кода.'),
								referenceManual('Clarino.css.template', $C.css.template, {
									border:markup(
										p('Формирует описание стиля рамки.'),
										p('Входные параметры:'),
										ol(
											li($C.html.b('width'), ' - ширина рамки в пикселях'),
											li($C.html.b('color'), ' - цвет рамки (необязательный)'),
											li($C.html.b('style'), ' - стиль рамки (необязательный)')
										),
										p('Например, ', 
											testSample('Clarino.css.template.border(1, "#f00", "solid")', '1px solid #f00'),
											', а при использовании параметров по умолчанию, ',
											testSample('Clarino.css.template.border(1)', '1px solid #000'),
											'.'
										)
									),
									linearGradient:markup(
										p('Формирует кроссбраузерное описание линейного градиента.'),
										p('Входные параметры:'),
										ol(
											li($C.html.b('angle'), ' - угол поворота градиента'),
											li($C.html.b('color1'), ' - первый цвет'),
											li($C.html.b('color2'), ' - второй цвет')
										),
										(function(){
											var src = 'Clarino.css.template.linearGradient(90, "#f00", "#0f0")';
											var expected = [
												'#f00',
												'-webkit-linear-gradient(90deg,#f00,#0f0)',
												'-o-linear-gradient(90deg,#f00,#0f0)',
												'-moz-linear-gradient(90deg,#f00,#0f0)',
												'linear-gradient(90deg,#f00,#0f0)'
											];
											return markup(
												p('Например, следующий вызов: ', code(src), ' вернет следующий массив значений: '),
												ul(apply(expected, function(x){
													return li(x)
												})),
												test(function(){
													assert((new Function('return '+src))(), expected)
												}),
												p('Пример использования данного шаблона при формировании таблицы стилей:'),
												codesample([
													'Clarino.css.stylesheet({',
													'	"div.attention":{',
													'		background: Clarino.css.template.linearGradient(45, "#f00", "#fff")',
													'	}',
													'}'
												])
											);
										})()
									)
								})
							),
							/* *************************
							rules: markup(
								p('Формирует код CSS-правил'),
								test("CSS Rules", "Extensions", function(){
									var anm = Clarino.css.rules('@keyframes example', {
										from:{backgroundColor:'red'},
										to:{backgroundColor:'green'}
									});
									
									assert(anm, '@keyframes example{\nfrom{\nbackground-color : red ;\n}\nto{\nbackground-color : green ;\n}\n}');
								})
							),
							writeRules: markup(
								p('Записывает CSS-правила, сформированные методом ', code('Clarino.css.rules()', ' в поток вывода документа'))
							),
							**************************** */
							attributes: markup(
								p('Словарь для определения сокращенных названий CSS-атрибутов. Ключ - сокращенное название атрибута, для использования в методах', code('Clarino.css.stylesheet()'), ' и ', code('Clarino.css.writeStylesheet()'), '. Значение - стандартное имя CSS-атрибута, которое будет вставлено в формируемый CSS-код.')
							)
						})
					))
				))
			);
		}}

		function buildToc(root){
			root = root || $('.manual');
			function tocLevel(root){with($H){
				var content = root.find('>.sectionContent');
				if(!content.length) content = root;
				var sections = content.find('>.section').toArray();
				if(!sections.length) return; // 'NO Sections';
				return ul(
					$C.apply(sections, function(sct){sct=$(sct);
						var sctID = sct.find('a').attr('name'),
							sctTitle = sct.find('.title').html();
						return li(
							a({href:'#'+sctID}, sctTitle),
							tocLevel(sct)
						);
					})
				);
			}}
			var hcode = tocLevel(root);
			//console.log(hcode);
			$('.pnlToc').html(hcode);
		}

		function bindEvents(){
			$('.manual')
				.find('.lnkRoll').click(function(){var self = $(this);
					var pnl = self.parent().parent().find('.sectionContent');
					if(pnl.is(':visible')){
						self.html('&#x25BC;').attr({title:'Развернуть'});
						pnl.fadeOut();
					}
					else{
						self.html('&#x25B2;').attr({title:'Свернуть'});
						pnl.fadeIn();
					}
				}).end()
				.find('.skinSelector select').change(function(){
					var skinID = $(this).val();
					setSkin(skinID);
					localStorage.setItem('clarinoManualSkin', skinID);
				}).end()
			;
		}

		function setSkin(skinID){
			$('#skin').html($C.css.stylesheet(Skins[skinID].styles));
		}

		function initSkin(){
			var skinID = localStorage.getItem('clarinoManualSkin') || 'default';
			setSkin(skinID);
			$('.manual .skinSelector select').val(skinID);
		}

		$(function(){
			$('head title').html(Settings.title);
			$('body').html(manual());
			bindEvents();
			buildToc();
			initSkin();
			if(errorsDetected) $('.pnlErrorsDetected').show();
		});
	})(jQuery, Clarino.version('0.1.0'));
	</script>
	<style id="skin"></style>
</head>
<body></body>
</html>
